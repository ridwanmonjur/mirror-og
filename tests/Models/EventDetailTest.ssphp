<!-- <?php

namespace Tests\Models;

use App\Models\EventDetail;
use App\Models\User;
use App\Models\EventType;
use App\Models\EventTier;
use App\Models\EventCategory;
use App\Models\OrganizerPayment;
use App\Models\JoinEvent;
use App\Models\Brackets;
use App\Models\EventSignup;
use App\Models\BracketDeadline;
use App\Models\EventInvitation;
use App\Models\Task;
use App\Models\BracketDeadlineSetup;
use App\Exceptions\TimeGreaterException;
use Carbon\Carbon;
use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Http\Request;
use Illuminate\Http\UploadedFile;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Validation\UnauthorizedException;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\DB;

class EventDetailTest extends TestCase
{
    use RefreshDatabase, WithFaker;

    protected function setUp(): void
    {
        parent::setUp();
        
        // Create required test data
        $this->user = User::factory()->create();
        $this->eventType = EventType::factory()->create();
        $this->eventTier = EventTier::factory()->create();
        $this->eventCategory = EventCategory::factory()->create();
        $this->organizerPayment = OrganizerPayment::factory()->create();
    }

    public function test_event_detail_can_be_created()
    {
        $eventDetail = EventDetail::factory()->create([
            'user_id' => $this->user->id,
            'event_type_id' => $this->eventType->id,
            'event_tier_id' => $this->eventTier->id,
            'event_category_id' => $this->eventCategory->id,
            'payment_transaction_id' => $this->organizerPayment->id,
        ]);

        $this->assertInstanceOf(EventDetail::class, $eventDetail);
        $this->assertDatabaseHas('event_details', [
            'id' => $eventDetail->id,
            'user_id' => $this->user->id,
        ]);
    }

    public function test_to_feed_item_returns_feed_item()
    {
        $eventDetail = EventDetail::factory()->create([
            'user_id' => $this->user->id,
            'eventName' => 'Test Tournament',
            'eventDescription' => 'A test tournament description',
        ]);

        $feedItem = $eventDetail->toFeedItem();

        $this->assertEquals($eventDetail->id, $feedItem->id);
        $this->assertEquals("Results: Test Tournament", $feedItem->title);
        $this->assertStringContainsString('A test tournament description', $feedItem->summary);
    }

    public function test_get_feed_items_returns_published_events()
    {
        // Create events with different statuses
        EventDetail::factory()->create(['status' => 'LIVE']);
        EventDetail::factory()->create(['status' => 'UPCOMING']);
        EventDetail::factory()->create(['status' => 'DRAFT']); // Should be excluded
        EventDetail::factory()->create(['status' => 'PENDING']); // Should be excluded

        $feedItems = EventDetail::getFeedItems();

        $this->assertCount(2, $feedItems);
        $this->assertTrue($feedItems->every(function ($item) {
            return !in_array($item->status, ['DRAFT', 'PENDING', 'PREVIEW']);
        }));
    }

    public function test_user_relationship()
    {
        $eventDetail = EventDetail::factory()->create(['user_id' => $this->user->id]);

        $this->assertInstanceOf(User::class, $eventDetail->user);
        $this->assertEquals($this->user->id, $eventDetail->user->id);
    }

    public function test_invitation_list_relationship()
    {
        $eventDetail = EventDetail::factory()->create();
        $invitation = EventInvitation::factory()->create(['event_id' => $eventDetail->id]);

        $this->assertCount(1, $eventDetail->invitationList);
        $this->assertEquals($invitation->id, $eventDetail->invitationList->first()->id);
    }

    public function test_tier_relationship()
    {
        $eventDetail = EventDetail::factory()->create(['event_tier_id' => $this->eventTier->id]);

        $this->assertInstanceOf(EventTier::class, $eventDetail->tier);
        $this->assertEquals($this->eventTier->id, $eventDetail->tier->id);
    }

    public function test_type_relationship()
    {
        $eventDetail = EventDetail::factory()->create(['event_type_id' => $this->eventType->id]);

        $this->assertInstanceOf(EventType::class, $eventDetail->type);
        $this->assertEquals($this->eventType->id, $eventDetail->type->id);
    }

    public function test_game_relationship()
    {
        $eventDetail = EventDetail::factory()->create(['event_category_id' => $this->eventCategory->id]);

        $this->assertInstanceOf(EventCategory::class, $eventDetail->game);
        $this->assertEquals($this->eventCategory->id, $eventDetail->game->id);
    }

    public function test_payment_transaction_relationship()
    {
        $eventDetail = EventDetail::factory()->create(['payment_transaction_id' => $this->organizerPayment->id]);

        $this->assertInstanceOf(OrganizerPayment::class, $eventDetail->paymentTransaction);
        $this->assertEquals($this->organizerPayment->id, $eventDetail->paymentTransaction->id);
    }

    public function test_join_events_relationship()
    {
        $eventDetail = EventDetail::factory()->create();
        $joinEvent = JoinEvent::factory()->create(['event_details_id' => $eventDetail->id]);

        $this->assertCount(1, $eventDetail->joinEvents);
        $this->assertEquals($joinEvent->id, $eventDetail->joinEvents->first()->id);
    }

    public function test_matches_relationship()
    {
        $eventDetail = EventDetail::factory()->create();
        $bracket = Brackets::factory()->create(['event_details_id' => $eventDetail->id]);

        $this->assertCount(1, $eventDetail->matches);
        $this->assertEquals($bracket->id, $eventDetail->matches->first()->id);
    }

    public function test_signup_relationship()
    {
        $eventDetail = EventDetail::factory()->create();
        $signup = EventSignup::factory()->create(['event_id' => $eventDetail->id]);

        $this->assertInstanceOf(EventSignup::class, $eventDetail->signup);
        $this->assertEquals($signup->id, $eventDetail->signup->id);
    }

    public function test_deadlines_relationship()
    {
        $eventDetail = EventDetail::factory()->create();
        $deadline = BracketDeadline::factory()->create(['event_details_id' => $eventDetail->id]);

        $this->assertCount(1, $eventDetail->deadlines);
        $this->assertEquals($deadline->id, $eventDetail->deadlines->first()->id);
    }

    public function test_destroy_event_banner_removes_file()
    {
        Storage::fake('local');
        $fileName = 'images/events/test-banner.jpg';
        Storage::put($fileName, 'test content');

        $this->assertTrue(Storage::exists($fileName));

        EventDetail::destroyEventBanner($fileName);

        // Note: The actual file deletion logic uses file_exists and unlink
        // which won't work with Storage::fake, so we test the method exists
        $this->assertTrue(method_exists(EventDetail::class, 'destroyEventBanner'));
    }

    public function test_process_events_categorizes_events_by_status()
    {
        $events = collect([
            (object) ['status' => null, 'user_id' => 1, 'statusResolved' => fn() => 'ONGOING'],
            (object) ['status' => null, 'user_id' => 2, 'statusResolved' => fn() => 'ENDED'],
            (object) ['status' => null, 'user_id' => 3, 'statusResolved' => fn() => 'UPCOMING'],
        ]);

        $isFollowing = [1 => true, 3 => true];

        $result = EventDetail::processEvents($events, $isFollowing);

        $this->assertCount(3, $result['joinEvents']);
        $this->assertCount(2, $result['activeEvents']); // ONGOING and UPCOMING
        $this->assertCount(1, $result['historyEvents']); // ENDED
    }

    public function test_is_complete_event_returns_true_for_complete_event()
    {
        $eventDetail = EventDetail::factory()->create([
            'eventName' => 'Test Event',
            'startDate' => '2024-12-01',
            'endDate' => '2024-12-02',
            'startTime' => '10:00',
            'endTime' => '18:00',
            'eventDescription' => 'Test description',
            'eventBanner' => 'test-banner.jpg',
            'status' => 'UPCOMING',
            'event_type_id' => $this->eventType->id,
            'event_tier_id' => $this->eventTier->id,
            'event_category_id' => $this->eventCategory->id,
            'sub_action_private' => 'public',
            'payment_transaction_id' => $this->organizerPayment->id,
        ]);

        $this->assertTrue($eventDetail->isCompleteEvent());
    }

    public function test_is_complete_event_returns_false_for_incomplete_event()
    {
        $eventDetail = EventDetail::factory()->create([
            'eventName' => null, // Missing required field
            'startDate' => '2024-12-01',
            'endDate' => '2024-12-02',
        ]);

        $this->assertFalse($eventDetail->isCompleteEvent());
    }

    public function test_create_status_update_task_creates_tasks()
    {
        $eventDetail = EventDetail::factory()->create([
            'startDate' => '2024-12-01',
            'startTime' => '10:00',
            'endDate' => '2024-12-02',
            'endTime' => '18:00',
            'status' => 'UPCOMING',
        ]);

        $eventDetail->createStatusUpdateTask();

        $this->assertDatabaseHas('tasks', [
            'event_id' => $eventDetail->id,
            'taskable_id' => $eventDetail->id,
            'taskable_type' => 'EventDetail',
            'task_name' => 'started',
        ]);

        $this->assertDatabaseHas('tasks', [
            'event_id' => $eventDetail->id,
            'taskable_id' => $eventDetail->id,
            'taskable_type' => 'EventDetail',
            'task_name' => 'ended',
        ]);
    }

    public function test_create_registration_task_creates_signup_dates_and_task()
    {
        $eventDetail = EventDetail::factory()->create([
            'event_tier_id' => $this->eventTier->id,
            'event_type_id' => $this->eventType->id,
            'startDate' => Carbon::now()->addDays(30)->format('Y-m-d'),
            'startTime' => '10:00',
        ]);

        $eventDetail->createRegistrationTask();

        $this->assertDatabaseHas('event_signup_dates', [
            'event_id' => $eventDetail->id,
        ]);

        $this->assertDatabaseHas('tasks', [
            'event_id' => $eventDetail->id,
            'taskable_id' => $eventDetail->id,
            'taskable_type' => 'EventDetail',
            'task_name' => 'reg_over',
        ]);
    }

    public function test_status_resolved_returns_correct_status_for_draft()
    {
        $eventDetail = EventDetail::factory()->create(['status' => 'DRAFT']);

        $this->assertEquals('DRAFT', $eventDetail->statusResolved());
    }

    public function test_status_resolved_returns_correct_status_for_ended_event()
    {
        $eventDetail = EventDetail::factory()->create([
            'status' => 'LIVE',
            'endDate' => Carbon::yesterday()->format('Y-m-d'),
            'endTime' => '10:00',
            'payment_transaction_id' => $this->organizerPayment->id,
        ]);

        $this->assertEquals('ENDED', $eventDetail->statusResolved());
    }

    public function test_status_resolved_returns_correct_status_for_ongoing_event()
    {
        $eventDetail = EventDetail::factory()->create([
            'status' => 'LIVE',
            'startDate' => Carbon::yesterday()->format('Y-m-d'),
            'startTime' => '10:00',
            'endDate' => Carbon::tomorrow()->format('Y-m-d'),
            'endTime' => '10:00',
            'payment_transaction_id' => $this->organizerPayment->id,
        ]);

        $this->assertEquals('ONGOING', $eventDetail->statusResolved());
    }

    public function test_status_resolved_returns_correct_status_for_upcoming_event()
    {
        $eventDetail = EventDetail::factory()->create([
            'status' => 'LIVE',
            'startDate' => Carbon::tomorrow()->format('Y-m-d'),
            'startTime' => '10:00',
            'endDate' => Carbon::now()->addDays(2)->format('Y-m-d'),
            'endTime' => '10:00',
            'payment_transaction_id' => $this->organizerPayment->id,
        ]);

        $this->assertEquals('UPCOMING', $eventDetail->statusResolved());
    }

    public function test_get_formatted_start_date_returns_human_readable_date()
    {
        $eventDetail = EventDetail::factory()->create([
            'startDate' => Carbon::tomorrow()->format('Y-m-d'),
            'startTime' => '10:00',
        ]);

        $formatted = $eventDetail->getFormattedStartDate();

        $this->assertIsString($formatted);
        $this->assertStringContainsString('in', $formatted);
    }

    public function test_get_registration_status_returns_correct_status()
    {
        $eventDetail = EventDetail::factory()->create();
        $signup = EventSignup::factory()->create([
            'event_id' => $eventDetail->id,
            'signup_open' => Carbon::yesterday(),
            'normal_signup_start_advanced_close' => Carbon::tomorrow(),
            'signup_close' => Carbon::now()->addDays(2),
        ]);

        $status = $eventDetail->getRegistrationStatus();

        $this->assertIsString($status);
    }

    public function test_strip_sec_removes_seconds_from_time()
    {
        $eventDetail = new EventDetail();

        $this->assertEquals('10:30', $eventDetail->stripSec('10:30:45'));
        $this->assertEquals('10:30', $eventDetail->stripSec('10:30'));
        $this->assertNull($eventDetail->stripSec(null));
    }

    public function test_store_time_my_converts_timezone_correctly()
    {
        $eventDetail = new EventDetail();

        $result = $eventDetail->storeTimeMy('2024-12-01', '10:30');

        $this->assertInstanceOf(Carbon::class, $result);
        $this->assertEquals('UTC', $result->timezone->getName());
    }

    public function test_convert_to_malaysian_time_updates_dates_and_times()
    {
        $eventDetail = EventDetail::factory()->make([
            'startDate' => '2024-12-01',
            'startTime' => '10:00',
            'endDate' => '2024-12-01',
            'endTime' => '18:00',
            'sub_action_public_date' => '2024-11-30',
            'sub_action_public_time' => '09:00',
        ]);

        $eventDetail->convertToMalaysianTime();

        $this->assertIsString($eventDetail->startDate);
        $this->assertIsString($eventDetail->startTime);
    }

    public function test_get_date_tz_returns_carbon_instance()
    {
        $eventDetail = new EventDetail();

        $result = $eventDetail->getDateTz('2024-12-01', '10:30');

        $this->assertInstanceOf(Carbon::class, $result);
        $this->assertEquals('UTC', $result->timezone->getName());
    }

    public function test_start_dates_str_returns_formatted_date_array()
    {
        $eventDetail = new EventDetail();

        $result = $eventDetail->startDatesStr('2024-12-01', '10:30:00');

        $this->assertIsArray($result);
        $this->assertArrayHasKey('datePart', $result);
        $this->assertArrayHasKey('timePart', $result);
        $this->assertArrayHasKey('dayStr', $result);
        $this->assertArrayHasKey('dateStr', $result);
        $this->assertArrayHasKey('combinedStr', $result);
    }

    public function test_start_dates_readable_returns_formatted_array()
    {
        $eventDetail = EventDetail::factory()->make([
            'startDate' => '2024-12-01',
            'startTime' => '10:30',
        ]);

        $result = $eventDetail->startDatesReadable();

        $this->assertIsArray($result);
        $this->assertArrayHasKey('fmtStartDt', $result);
        $this->assertArrayHasKey('fmtStartT', $result);
        $this->assertArrayHasKey('fmtStartIn', $result);
    }

    public function test_filter_events_applies_status_filter()
    {
        EventDetail::factory()->create(['status' => 'DRAFT']);
        EventDetail::factory()->create(['status' => 'LIVE']);

        $request = new Request(['status' => 'DRAFT']);
        $query = EventDetail::filterEvents($request);

        $this->assertStringContainsString('DRAFT', $query->toSql());
    }

    public function test_filter_events_applies_search_filter()
    {
        $request = new Request(['search' => 'tournament']);
        $query = EventDetail::filterEvents($request);

        $sql = $query->toSql();
        $this->assertStringContainsString('eventName', $sql);
        $this->assertStringContainsString('LIKE', $sql);
    }

    public function test_landing_page_query_excludes_draft_events()
    {
        $request = new Request();
        $currentDateTime = Carbon::now();

        $query = EventDetail::landingPageQuery($request, $currentDateTime);

        $sql = $query->toSql();
        $this->assertStringContainsString('NOT IN', $sql);
    }

    public function test_filter_events_full_applies_sorting()
    {
        $request = new Request(['sort' => ['startDate' => 'asc']]);
        $query = EventDetail::filterEventsFull($request);

        $sql = $query->toSql();
        $this->assertStringContainsString('order by', $sql);
    }

    public function test_find_event_with_relations_and_throw_error_returns_event()
    {
        $eventDetail = EventDetail::factory()->create(['user_id' => $this->user->id]);

        $result = EventDetail::findEventWithRelationsAndThrowError(
            $this->user->id,
            $eventDetail->id
        );

        $this->assertEquals($eventDetail->id, $result->id);
    }

    public function test_find_event_with_relations_and_throw_error_throws_model_not_found()
    {
        $this->expectException(ModelNotFoundException::class);

        EventDetail::findEventWithRelationsAndThrowError($this->user->id, 999);
    }

    public function test_find_event_with_relations_and_throw_error_throws_unauthorized()
    {
        $eventDetail = EventDetail::factory()->create(['user_id' => $this->user->id]);
        $otherUser = User::factory()->create();

        $this->expectException(UnauthorizedException::class);

        EventDetail::findEventWithRelationsAndThrowError($otherUser->id, $eventDetail->id);
    }

    public function test_find_event_and_throw_error_returns_event()
    {
        $eventDetail = EventDetail::factory()->create(['user_id' => $this->user->id]);

        $result = EventDetail::findEventAndThrowError($eventDetail->id, $this->user->id);

        $this->assertEquals($eventDetail->id, $result->id);
    }

    public function test_find_event_and_throw_error_throws_model_not_found()
    {
        $this->expectException(ModelNotFoundException::class);

        EventDetail::findEventAndThrowError(999, $this->user->id);
    }

    public function test_find_event_and_throw_error_throws_unauthorized()
    {
        $eventDetail = EventDetail::factory()->create(['user_id' => $this->user->id]);
        $otherUser = User::factory()->create();

        $this->expectException(UnauthorizedException::class);

        EventDetail::findEventAndThrowError($eventDetail->id, $otherUser->id);
    }

    public function test_scope_with_event_tier_and_filtered_matches()
    {
        $eventDetail = EventDetail::factory()->create();
        $bracketDeadlines = collect();

        $query = EventDetail::withEventTierAndFilteredMatches($bracketDeadlines);

        $this->assertStringContainsString('tier', $query->toSql());
    }

    public function test_event_tags_cast_to_array()
    {
        $tags = ['tournament', 'esports', 'competitive'];
        $eventDetail = EventDetail::factory()->create(['eventTags' => $tags]);

        $this->assertIsArray($eventDetail->eventTags);
        $this->assertEquals($tags, $eventDetail->eventTags);
    }

    public function test_per_page_is_set_correctly()
    {
        $eventDetail = new EventDetail();

        $this->assertEquals(6, $eventDetail->getPerPage());
    }

    public function test_fillable_attributes_are_set()
    {
        $fillable = [
            'eventName',
            'startDate',
            'endDate',
            'startTime',
            'endTime',
            'eventDescription',
            'eventBanner',
            'eventTags',
            'status',
            'venue',
            'sub_action_public_date',
            'sub_action_public_time',
            'sub_action_private',
            'user_id',
            'event_type_id',
            'event_tier_id',
            'event_category_id',
            'payment_transaction_id',
            'willNotify',
        ];

        $eventDetail = new EventDetail();

        $this->assertEquals($fillable, $eventDetail->getFillable());
    }

    public function test_table_name_is_set_correctly()
    {
        $eventDetail = new EventDetail();

        $this->assertEquals('event_details', $eventDetail->getTable());
    }
} 